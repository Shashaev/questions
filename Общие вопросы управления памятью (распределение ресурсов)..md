В мультипрограммном режиме работы ЭВМ в оперативной памяти одновременно находятся и выполняются несколько независимых программ (процессов). Это требует решения двух **фундаментальных задач**:

1. **Распределение (разделение) свободной памяти:** Как эффективно и справедливо выделять ограниченный ресурс ОЗУ между конкурирующими процессами?
2. **Защита памяти:** Как гарантировать, что одна программа не сможет случайно или намеренно повредить или прочитать данные другой программы или самой операционной системы (ОС)?

**2. Распределение памяти: Эволюция подходов**

- **Монопольное распределение (Одна программа):** Вся память принадлежит единственной программе. Проблем распределения и защиты нет, но ресурсы используются крайне неэффективно.    
- **Статическое распределение (Фиксированные разделы):**
    - Память заранее разделена на фиксированные по размеру разделы.
    - Каждой входящей программе выделяется подходящий по размеру свободный раздел.
    - **Плюсы:** Простота реализации.
    - **Минусы:**
        - **Низкая эффективность использования памяти:** Если программа меньше раздела, остается "дыра" (внутренняя фрагментация). Большая программа может не поместиться ни в один раздел.
        - **Жесткость:** Не адаптируется к разным размерам программ.
- **Динамическое распределение (Перемещаемые программы):**
    - Программы специально готовятся к загрузке в произвольное место памяти (перемещаемые).
    - Память выделяется _по мере поступления_ программ в непрерывные свободные области необходимого размера.
    - **Плюсы:** Гораздо более гибкое и эффективное использование памяти по сравнению со статическим.
    - **Минусы:**
        - **Фрагментация:** По мере загрузки и выгрузки программ в памяти образуются свободные участки ("дыры") разного размера, разбросанные по всему адресному пространству. Со временем может возникнуть ситуация, когда суммарный объем свободной памяти достаточен для новой программы, но нет _одного непрерывного_ участка подходящего размера (внешняя фрагментация). Это блокирует запуск новых программ.
        - **Дефрагментация:** Для борьбы с внешней фрагментацией периодически требуется выполнять ресурсоемкую операцию "сборки мусора" (дефрагментации) – перемещать загруженные программы в памяти так, чтобы все свободные участки слились в один большой непрерывный блок.
    
    **Защита памяти: Механизмы и методы**  
Необходимость защиты вытекает из самой сути мультипрограммирования: ошибка или злой умысел одной программы не должны влиять на работу других или ОС. Средства защиты выполняют:
- Проверку корректности адреса (в пределах допустимого диапазона).
- Проверку разрешения доступа (может ли программа _вообще_ обращаться к этой ячейке/области).
- Проверку прав доступа (разрешены ли операции чтения, записи, исполнения).

**Основные классические подходы к защите памяти:**
- **Защита отдельных ячеек памяти:**
    - Каждая ячейка памяти имеет дополнительный "разряд защиты" (бит).
    - Установка бита (например, в '1') может запрещать запись или любой доступ.
    - **Плюсы:** Максимально детальная защита.
    - **Минусы:** Огромные накладные расходы по памяти (дополнительный бит на каждую ячейку) и сложность управления.
        
- **Методы граничных регистров:**
    - **Базовый регистр (`fence`):** Разделяет память ОС и пользовательских программ. Адрес доступа сравнивается со значением регистра. Защищает ОС от приложений, но не приложения друг от друга (подходит для однозадачных ОС).
    - **Пара регистров: Базовый (`Base`) и Граничный (`Bound`/`Limit`):**
        - Для _каждого_ процесса ОС загружает в специальные регистры ЦП начальный (базовый) адрес его области памяти и ее размер (границу).
        - При _каждом_ обращении программы к памяти аппаратно проверяется: `(Базовый Адрес <= Физический Адрес < Базовый Адрес + Граница)`.
        - Нарушение границы вызывает прерывание, передающее управление ОС.
        - **Плюсы:** Относительно просто, эффективно.
        - **Минусы:** Требует, чтобы память процесса была _непрерывной_. Не подходит для сложных схем распределения (страницы, сегменты).
            
- **Метод ключей защиты:**
    - Память разбивается на блоки (например, по 2КБ в IBM OS/360). Каждому блоку присваивается **ключ защиты** (напр., 4-битный).
    - Каждой программе (процессу) присваивается **ключ программы**.
    - Доступ программы к блоку разрешен, если:
        - Ключ программы совпадает с ключом защиты блока (блок "принадлежит" программе), ИЛИ
        - Ключ программы или ключ защиты имеет специальное значение (например, 0 - для ОС или общедоступных блоков).
    - **Плюсы:** Гибкость (можно создавать общие области), не требует непрерывности памяти процесса.
    - **Минусы:** Дополнительные затраты памяти на хранение ключей, сложность управления.
        
- **Защита памяти по привилегиям (Кольцевая модель):**
    - Программы и данные распределяются по уровням привилегий (кольцам). Например, кольцо 0 - ядро ОС (максимум привилегий), кольцо 3 - пользовательские приложения (минимум привилегий).
    - Программа из кольца с _меньшими_ привилегиями (например, 3) не может напрямую обращаться к коду или данным программы в кольце с _большими_ привилегиями (например, 0). Попытка доступа вызывает исключение.
    - **Плюсы:** Мощная изоляция, основа современных защищенных ОС.
    - **Минусы:** Требует сложной поддержки как со стороны аппаратуры (флаги привилегий в регистре состояния, механизмы переключения колец), так и со стороны ОС.
![[Pasted image 20250615140636.png]]