# 4. Микропрограммные автоматы с принудительной адресацией, реализация механизма ветвлений.

#Редактор_Шашаев_Кирилл 

## Краткий ответ

Рекомендую прочитать **первоисточник**.

**Микропрограммные автоматы с принудительной адресацией** используют явное указание адреса следующей микрокоманды в текущей микрокоманде. Ветвление реализуется через **осведомительные сигналы (X)**, которые определяют выбор следующего адреса (A1 или A2) с помощью мультиплексора (MS).
- **Принудительная адресация**: каждая микрокоманда содержит адрес следующей, что позволяет гибко управлять потоком выполнения.
- **Ветвление по одной переменной**: проверяется одно условие (Xi), и в зависимости от его значения выбирается один из двух адресов.
- **Ветвление по нескольким переменным**: более эффективно, но требует дополнительных разрядов в микрокоманде (обычно 4–5).

**Недостатки**:
1. Нерациональное использование памяти.
2. Для многопеременных условий требуются дополнительные циклы (решается многопутным ветвлением).

**Реализация**:
- Память микрокода (ПЗУ) хранит микропрограммы.    
- Управляющие сигналы (Y) формируются на основе текущей микрокоманды.
- Схема включает мультиплексоры, регистры (A, B) и счётчики (i, A1, A2).

Это обеспечивает выполнение сложных команд (плавающая точка, криптография) с поддержкой условной логики.

---
## Первоисточник информации
---
**Микропрограммный автомат** - часть УУ. В современных УУ может быть несколько **автоматов** (0 - 12, почти всегда).

В процессе **обработки команды** ([[Обобщенная структура центрального процессора|Цикл команды]]) происходит этап **декодирования**, который как ни странно выполняет **Декодер**. Если команда принадлежит к некоторой группе команд, декодер передаёт её **микропрограммному автомату** (передаёт выполнение). Особенность этой группы команд - **высокая сложность**, **долгое выполнение**,  **нужда в условной логике**. Пример таких команд: *операции с числами с правеющей точкой (деление), векторные команды, криптография*.

После активации **микропрограммного автомата** он однозначно по **машинной команде** подбирает **микропрограмму**, исполнение которой приводит к исполнению **машинной команды**.

**Микропрограмма** - последовательность **микрокоманд**. **Микрокоманда** — это команда управления логическими схемами микропроцессора для обеспечения выполнения микрооперации. К примеру **микрокомандой** может выступать сложение двух чисел, которое выполняет **АЛУ**.

**Микропрограммы** хранятся в **ПЗУ** ([[Память ЭВМ]]), следовательно их нельзя изменить (перезаписать).

Большинство команд **не используют микропрограммы** (жёсткая логика). 

**Принудительная адресация** микрокоманды (**МК**) заключается в том, что в каждой микрокоманде указывается *адрес следующей микрокоманды* (**явное указание**, не выполнение просто микрокоманды, которая расположена после текущей ([[Микропрограммные автоматы с естественной адресацией]])). Адрес следующей микрокоманды может задаваться безусловно, независимо от **значений признаков (**осведомительных сигналов**, отображающих текущее состояние операционных блоков процессора) или выбираться по условию, определяемому текущими значениями **осведомительных сигналов**. Для этого в адресную часть МК кроме адресных полей включаются **поля для задания условий** (*осведомительных сигналов*).

![[Pasted image 20250614222253.png]]

**Ветвление** может быть по **одной** или **нескольким переменных**. 

![[Pasted image 20250614222308.png]]

На изображении представлена **схема микропрограммного автомата (МПА)** или связанного с ним управляющего устройства. Вот расшифровка элементов:

Ключевые компоненты схемы
1. **X (x0...xm)** — Входные сигналы (условия/флаги).
2. **MS** — Мультиплексор (выбирает следующий адрес микрокоманды).
3. **Y** — Выходные управляющие сигналы (для АЛУ, регистров, памяти).
4. **A, B** — Регистры хранения промежуточных данных или адресов.
5. **PAMK** — Память микрокода (ПЗУ, хранящее микропрограммы). 
6. **i, A1, A2** — Счётчики или адресные регистры (для перехода между микрокомандами).

**_Ветвление по одной переменной_**

Если проверяемых значений много, то нужно отвести поле, в котором будет номер проверяемого условия (i). i - для номера проверяющего условия.

 i – выбирает какую переменную проверять (x0,…,xn). После ее выбора выбирается адрес ветвления A1;A2.

_1-й недостаток_ – нерациональное использование памяти
_2-й недостаток_ – если результат зависит от нескольких переменных, то для n переменных нужно организовать (n-1) холостых циклов.

Решение 2-го недостатка:
Организовать ветвление по нескольким направлениям, этот способ намного эффективнее, но возникает проблема с реализацией. Обычно выбирают 4-5 разрядов ветвления.  x0,x1…x4(xn).